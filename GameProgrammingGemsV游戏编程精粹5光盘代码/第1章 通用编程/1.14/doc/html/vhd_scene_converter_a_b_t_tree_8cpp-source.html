<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>vhdABTTree: vhdSceneConverterABTTree.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.8 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<h1>vhdSceneConverterABTTree.cpp</h1><pre class="fragment"><div>00001 
00002 <span class="comment">//      Copyright : Sebastien Schertenleib</span>
00003 <span class="comment">//                : VRLab-EPFL</span>
00004 <span class="comment">//</span>
00005 <span class="comment">//      Email :Sebastien.Schertenleib@epfl.ch</span>
00006 <span class="comment">//</span>
00007 <span class="comment">//      This source code is a part of the Game Programming Gems 5 Source Code</span>
00008 <span class="comment">//</span>
00009 <span class="comment">//  Permission to copy, modify, reproduce or redistribute this source code is</span>
00010 <span class="comment">//  granted provided the above copyright notice is retained in the resulting </span>
00011 <span class="comment">//  source code.</span>
00012 <span class="comment">//</span>
00013 <span class="comment">//      This file is provided 'as is' with no expressed or implied warranty.</span>
00014 <span class="comment">//      The author accepts no liability if it causes any damage to your computer.</span>
00015 <span class="comment">//</span>
00016 <span class="comment">//      Do expect bugs.</span>
00017 <span class="comment">//      Please let me know of any bugs/mods/improvements.</span>
00018 <span class="comment">//      and I will try to fix/incorporate them into this file.</span>
00019 <span class="comment">//      Enjoy!</span>
00020 <span class="comment">//</span>
00022 <span class="comment"></span>
00023 
00024 <span class="preprocessor">#include "vhdSceneConverterABTTree.h"</span>
00025 <span class="preprocessor">#include "vhdABTTree.h"</span>
00026 <span class="preprocessor">#include &lt;float.h&gt;</span>
00027 <span class="preprocessor">#include &lt;iostream&gt;</span>
00028 
00029 <span class="comment">//for singleton</span>
00030 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> vhdSceneConverterABTTree&gt; <a class="code" href="classvhd_scene_converter_a_b_t_tree.html">vhdSceneConverterABTTree</a>* vhdSingleton &lt;vhdSceneConverterABTTree&gt;::ms_Singleton = 0;
00031 
00032 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vhdSceneConverterABTTree::ABTTREE_AXISX = 0;
00033 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vhdSceneConverterABTTree::ABTTREE_AXISY = 1;
00034 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vhdSceneConverterABTTree::ABTTREE_AXISZ = 2;
00035 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vhdSceneConverterABTTree::ABTTREE_AXISINVALID = 3;
00036 
00037 
00038 
<a name="l00039"></a><a class="code" href="classvhd_scene_converter_a_b_t_tree.html#a0">00039</a> <a class="code" href="classvhd_scene_converter_a_b_t_tree.html#a0">vhdSceneConverterABTTree::vhdSceneConverterABTTree</a>()
00040 {
00041 
00042         pDataRootNode = NULL;
00043 }
00044 
00045 
<a name="l00046"></a><a class="code" href="classvhd_scene_converter_a_b_t_tree.html#a1">00046</a> <a class="code" href="classvhd_scene_converter_a_b_t_tree.html#a1">vhdSceneConverterABTTree::~vhdSceneConverterABTTree</a>()
00047 {
00048 }
00049 
00050 
00051 
00052 
00053 <a class="code" href="classvhd_axis_aligned_box.html">vhdAxisAlignedBox</a> 
<a name="l00054"></a><a class="code" href="classvhd_scene_converter_a_b_t_tree.html#e0">00054</a> <a class="code" href="classvhd_scene_converter_a_b_t_tree.html#e0">vhdSceneConverterABTTree::findGlobalAABB</a>(<span class="keyword">const</span> ListAABB &amp; listAABB)
00055 {
00056         
00057         ListAABB::const_iterator it;
00058         <a class="code" href="classvhd_vector3.html">vhdVector3</a> vecMin, vecMax, vecGlobalMin(FLT_MAX,FLT_MAX,FLT_MAX), vecGlobalMax(-FLT_MAX,-FLT_MAX,-FLT_MAX);
00059         <span class="keywordflow">for</span> (it=listAABB.begin(); it!=listAABB.end(); ++it)
00060         {
00061                 vecMin = it-&gt;bbox.getMinimum();
00062                 vecMax = it-&gt;bbox.getMaximum();
00063                 <span class="keywordflow">if</span> (vecMin.<a class="code" href="classvhd_vector3.html#o0">x</a>&lt;vecGlobalMin.x) vecGlobalMin.x=vecMin.<a class="code" href="classvhd_vector3.html#o0">x</a>;
00064                 <span class="keywordflow">if</span> (vecMin.<a class="code" href="classvhd_vector3.html#o1">y</a>&lt;vecGlobalMin.y) vecGlobalMin.y=vecMin.<a class="code" href="classvhd_vector3.html#o1">y</a>;
00065                 <span class="keywordflow">if</span> (vecMin.<a class="code" href="classvhd_vector3.html#o2">z</a>&lt;vecGlobalMin.z) vecGlobalMin.z=vecMin.<a class="code" href="classvhd_vector3.html#o2">z</a>;
00066                 <span class="keywordflow">if</span> (vecMax.<a class="code" href="classvhd_vector3.html#o0">x</a>&gt;vecGlobalMax.<a class="code" href="classvhd_vector3.html#o0">x</a>) vecGlobalMax.<a class="code" href="classvhd_vector3.html#o0">x</a>=vecMax.<a class="code" href="classvhd_vector3.html#o0">x</a>;
00067                 <span class="keywordflow">if</span> (vecMax.<a class="code" href="classvhd_vector3.html#o1">y</a>&gt;vecGlobalMax.<a class="code" href="classvhd_vector3.html#o1">y</a>) vecGlobalMax.<a class="code" href="classvhd_vector3.html#o1">y</a>=vecMax.<a class="code" href="classvhd_vector3.html#o1">y</a>;
00068                 <span class="keywordflow">if</span> (vecMax.<a class="code" href="classvhd_vector3.html#o2">z</a>&gt;vecGlobalMax.<a class="code" href="classvhd_vector3.html#o2">z</a>) vecGlobalMax.<a class="code" href="classvhd_vector3.html#o2">z</a>=vecMax.<a class="code" href="classvhd_vector3.html#o2">z</a>;
00069         }
00070         <span class="keywordflow">return</span> <a class="code" href="classvhd_axis_aligned_box.html">vhdAxisAlignedBox</a>(vecGlobalMin.x,vecGlobalMin.y,vecGlobalMin.z, vecGlobalMax.<a class="code" href="classvhd_vector3.html#o0">x</a>,vecGlobalMax.<a class="code" href="classvhd_vector3.html#o1">y</a>,vecGlobalMax.<a class="code" href="classvhd_vector3.html#o2">z</a>);
00071 }
00072 
00073 
00074 <span class="preprocessor">#define TRIAL 20</span>
00075 <span class="preprocessor"></span>
00076 <span class="keywordtype">float</span> 
00077 vhdSceneConverterABTTree::_findBestSplitLocation (vhdSceneABTTreeNode *pParentNode ,<span class="keywordtype">int</span> axis, <span class="keywordtype">float</span>&amp; fSplitLoc,<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> uiNodeIndex)
00078 {
00079         <span class="comment">//get the AABB</span>
00080         <a class="code" href="classvhd_axis_aligned_box.html">vhdAxisAlignedBox</a> aabb = <a class="code" href="classvhd_scene_converter_a_b_t_tree.html#e0">findGlobalAABB</a>(pParentNode-&gt;listAABB);
00081         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> uiListSize = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) pParentNode-&gt;listAABB.size();
00082 
00083         <span class="keywordtype">int</span> i;
00084         <span class="keywordtype">float</span> a;
00085         <span class="keywordtype">float</span> fBestQual = -2.0;
00086         <span class="keywordtype">float</span> fInvNumObjects = 1.0 / float (uiListSize);
00087         <span class="keywordflow">for</span> (i = 0 ; i &lt; TRIAL ; i++)
00088         {
00089                 <span class="comment">// Calculate a possible split location.</span>
00090                 a = aabb.<a class="code" href="classvhd_axis_aligned_box.html#a2">getMinimum</a>()[axis] + float (i+1)*(aabb.<a class="code" href="classvhd_axis_aligned_box.html#a3">getMaximum</a>()[axis]-aabb.<a class="code" href="classvhd_axis_aligned_box.html#a2">getMinimum</a>()[axis])/float (TRIAL+1.0);
00091                 
00092                 
00093                 <span class="comment">// Now count the number of poly that are on the left and the number of objects completely on the right</span>
00094                 <span class="comment">// Normally the split function is much complex taking care of object complexity as well (rendering cost,....)</span>
00095                 
00096                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> uiLeft = 0;
00097                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> uiRight = 0;
00098                 
00099                 <span class="comment">//we go through each instance to find the proper index, so here we go</span>
00100                 ListAABB::iterator it;
00101                 <a class="code" href="classvhd_vector3.html">vhdVector3</a> vecMin, vecMax;
00102                 <span class="keywordflow">for</span> (it=pParentNode-&gt;listAABB.begin(); it!=pParentNode-&gt;listAABB.end(); ++it)
00103                 {
00104                         vecMin = it-&gt;bbox.getMinimum();
00105                         vecMax = it-&gt;bbox.getMaximum();
00106 
00107                         <span class="keywordflow">if</span> ((vecMin[axis] + (vecMax[axis]-vecMin[axis]) / 2.0f) &lt; a)
00108                         {
00109                                 ++uiLeft;       
00110                         }
00111                         <span class="keywordflow">else</span>
00112                         {
00113                                 ++uiRight;
00114                         }
00115                 }
00116                 
00117                 <span class="comment">// If we have no object on the left or right then this is a bad</span>
00118                 <span class="comment">// split which we should never take.</span>
00119                 <span class="keywordtype">float</span> fQual;
00120                 <span class="keywordflow">if</span> (uiLeft == 0 || uiRight == 0)
00121                 {
00122                         fQual = -1.0;
00123                 }
00124                 <span class="keywordflow">else</span>
00125                 {
00126                         fQual = 1.0 - (float (abs ((<span class="keywordtype">int</span>)(uiLeft-uiRight))) * fInvNumObjects);
00127                 }
00128                 <span class="keywordflow">if</span> (fQual &gt; fBestQual)
00129                 {
00130                         fBestQual = fQual;
00131                         fSplitLoc = a;
00132                 }
00133         }
00134         
00135         <span class="keywordflow">return</span> fBestQual;
00136 }
00137 
00138 
00139 
00140 
00141 <span class="keywordtype">void</span> 
<a name="l00142"></a><a class="code" href="classvhd_scene_converter_a_b_t_tree.html#a2">00142</a> <a class="code" href="classvhd_scene_converter_a_b_t_tree.html#a2">vhdSceneConverterABTTree::getChildren</a>(vhdSceneABTTreeNode *pParentNode ,<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nCurrentChildPosition,<a class="code" href="classvhd_axis_aligned_box.html">vhdAxisAlignedBox</a> &amp; boxLeft, <a class="code" href="classvhd_axis_aligned_box.html">vhdAxisAlignedBox</a> &amp; boxRight)
00143 {
00144         <span class="comment">// Here we have 2 or more objects.</span>
00145         <span class="comment">// We use FindBestSplitLocation() to see how we can best split this</span>
00146         <span class="comment">// node.</span>
00147         <span class="keywordtype">float</span> split_loc_x, split_loc_y, split_loc_z;
00148         <span class="keywordtype">float</span> qual_x = _findBestSplitLocation (pParentNode,vhdSceneConverterABTTree::ABTTREE_AXISX, split_loc_x,nCurrentChildPosition);
00149         <span class="keywordtype">float</span> qual_y = _findBestSplitLocation (pParentNode,vhdSceneConverterABTTree::ABTTREE_AXISY, split_loc_y,nCurrentChildPosition);
00150         <span class="keywordtype">float</span> qual_z = _findBestSplitLocation (pParentNode,vhdSceneConverterABTTree::ABTTREE_AXISZ, split_loc_z,nCurrentChildPosition);
00151 
00152         <span class="keywordtype">float</span> fSplitLocation;
00153         <span class="keywordtype">int</span> iSplitAxis;
00154         <span class="keywordflow">if</span> (qual_x &gt;= 0 &amp;&amp; qual_x &gt;= qual_y &amp;&amp; qual_x &gt;= qual_z)
00155         {
00156                 iSplitAxis = vhdSceneConverterABTTree::ABTTREE_AXISX;
00157                 fSplitLocation = split_loc_x;
00158         }
00159         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (qual_y &gt;= 0 &amp;&amp; qual_y &gt;= qual_x &amp;&amp; qual_y &gt;= qual_z)
00160         {
00161                 iSplitAxis = vhdSceneConverterABTTree::ABTTREE_AXISY;
00162                 fSplitLocation = split_loc_y;
00163         }
00164         <span class="keywordflow">else</span> 
00165         {
00166                 iSplitAxis = vhdSceneConverterABTTree::ABTTREE_AXISZ;
00167                 fSplitLocation = split_loc_z;
00168         }
00169 
00170         <span class="comment">//we have our splitter so we do the real collection then</span>
00171         
00172         <span class="comment">//we go through each instance to find the proper index, so here we go</span>
00173         ListAABB::iterator it;
00174         <a class="code" href="classvhd_vector3.html">vhdVector3</a> vecMin, vecMax;
00175         
00176         
00177         pParentNode-&gt;pLeft = <span class="keyword">new</span> vhdSceneABTTreeNode();
00178         pParentNode-&gt;pRight = <span class="keyword">new</span> vhdSceneABTTreeNode();
00179 
00180         <span class="keywordflow">for</span> (it=pParentNode-&gt;listAABB.begin(); it!=pParentNode-&gt;listAABB.end(); ++it)
00181         {
00182                 vecMin = it-&gt;bbox.getMinimum();
00183                 vecMax = it-&gt;bbox.getMaximum();
00184 
00185                 <span class="keywordflow">if</span> ((vecMin[iSplitAxis] + (vecMax[iSplitAxis]-vecMin[iSplitAxis]) / 2.0f) &lt; fSplitLocation)
00186                 {
00187                         pParentNode-&gt;pLeft-&gt;listAABB.push_back(*it);
00188 <span class="preprocessor">                        #ifdef TREE_DEBUG</span>
00189 <span class="preprocessor"></span>                        std::cout &lt;&lt; <span class="stringliteral">"name left "</span> &lt;&lt; it-&gt;strPath &lt;&lt; std::endl;
00190 <span class="preprocessor">                        #endif</span>
00191 <span class="preprocessor"></span>                }       
00192                 <span class="keywordflow">else</span>
00193                 {
00194                         pParentNode-&gt;pRight-&gt;listAABB.push_back(*it);
00195 <span class="preprocessor">                        #ifdef TREE_DEBUG</span>
00196 <span class="preprocessor"></span>                        std::cout &lt;&lt; <span class="stringliteral">"name right "</span> &lt;&lt; it-&gt;strPath &lt;&lt; std::endl;
00197 <span class="preprocessor">                        #endif</span>
00198 <span class="preprocessor"></span>                }
00199         }
00200 
00201         <span class="comment">//avoid that sub-child become empty</span>
00202         <span class="keywordflow">while</span> (pParentNode-&gt;pLeft-&gt;listAABB.size()&lt;2)
00203         {
00204                 <span class="comment">//we transfer one</span>
00205                 pParentNode-&gt;pLeft-&gt;listAABB.push_back(*pParentNode-&gt;pRight-&gt;listAABB.begin());
00206                 pParentNode-&gt;pRight-&gt;listAABB.pop_front();
00207         }
00208         <span class="keywordflow">while</span>  (pParentNode-&gt;pRight-&gt;listAABB.size()&lt;2)
00209         {
00210                 <span class="comment">//we transfer one</span>
00211                 pParentNode-&gt;pRight-&gt;listAABB.push_back(*pParentNode-&gt;pLeft-&gt;listAABB.begin());
00212                 pParentNode-&gt;pLeft-&gt;listAABB.pop_front();
00213         }
00214         
00215         <span class="comment">//we insert the current status in our map</span>
00216         vhdSceneConverterABTTree::getSingleton().<a class="code" href="classvhd_scene_converter_a_b_t_tree.html#o0">mapNodeChild</a>.insert(vhdSceneConverterABTTree::MapNodeChild::value_type(nCurrentChildPosition,*pParentNode));
00217         
00218         <span class="comment">//compute bbox</span>
00219         boxLeft = <a class="code" href="classvhd_scene_converter_a_b_t_tree.html#e0">findGlobalAABB</a>(pParentNode-&gt;pLeft-&gt;listAABB);
00220         boxRight = <a class="code" href="classvhd_scene_converter_a_b_t_tree.html#e0">findGlobalAABB</a>(pParentNode-&gt;pRight-&gt;listAABB);
00221 }
00222 
00223 
00224 
00225 
00226 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sun Oct 3 16:32:22 2004 for vhdABTTree by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.8 </small></address>
</body>
</html>
