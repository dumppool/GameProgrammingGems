//-------------------------------------------------------------------------------
// PlayerViz (Player Trace Visualizer) 
// Version 0.5 Released 08.10.2007
// Part of the CGUL (Common Games Understanding and Learning) Toolkit
//-------------------------------------------------------------------------------
//  Copyright (C) 2007 Priyesh N. Dixit and G. Michael Youngblood
//  Game Intelligence Group, Games + Learning Lab
//  The University of North Carolina at Charlotte
//  College of Computing and Informatics, Department of Computer Science
//  9201 University City Blvd, Charlotte, NC 28223-0001
//  {pndixit, youngbld}@uncc.edu
//-------------------------------------------------------------------------------
//  This program is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 2 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program; if not, write to the Free Software
//  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
//-------------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <FL/Fl_Menu_Bar.H>
#include <FL/Fl_Group.H>

#include "MainWindow.h"
#include <iostream>
#include <fstream>
using namespace std;

// ------------ Callbacks ------------ //

void guiCallback( Fl_Widget* w, void *data)
{
	((MainWindow*)data)->myGuiCallback(w);
}

void open_cb( Fl_Widget* w, void* data)
{
	Fl_File_Chooser* chooserPointer = ((MainWindow*)data)->getChooser();
	chooserPointer->show();
	while(chooserPointer->visible())
		Fl::wait();
	const char* file = chooserPointer->value();
	if (file == NULL)
		return;
	((MainWindow*)data)->getGLWidget()->readDataFile(file,NULL,NULL);
    ((MainWindow*)data)->setLastPath(string(file));
}

void openSSPS_cb( Fl_Widget* w, void* data)
{
	Fl_File_Chooser* chooserPointer = ((MainWindow*)data)->getSSPSChooser();
	chooserPointer->type(FL_SINGLE);
	chooserPointer->show();
	while(chooserPointer->visible())
		Fl::wait();
	const char* file = chooserPointer->value();
	if (file == NULL)
		return;
    
	((MainWindow*)data)->getGLWidget()->readDataFile(NULL,file,NULL);
	((MainWindow*)data)->setTitle(string("PlayerViz- "+string(file)).c_str());
	((MainWindow*)data)->setLastPath(string(file));    
}

void clear_cb( Fl_Widget* w, void* data)
{
	((MainWindow*)data)->getGLWidget()->clearData();
}

void quit_cb( Fl_Widget*, void* )
{
  exit( 0 );
}


// ------------ MainWindow definitions ------------ //


MainWindow::MainWindow(int argc, char** argv)
{
	// Most FL_ constructors are ( x position, y position, width, height, ...)

	// Every Fl object created between here and win->end() is
	// placed in the window
	win = new Fl_Window( 200, 200, WIDTH, HEIGHT+130, "PlayerViz- no file" );

	// Create the menu bar
	Fl_Menu_Bar* menu = new Fl_Menu_Bar( 0, 0, WIDTH, 30 );
	menu->box( FL_PLASTIC_UP_BOX );

	menu->add( "&File/&Open Player Trace", FL_CTRL + 'o',
			 (Fl_Callback *)open_cb, this ); 
	menu->add( "&File/Open &SSPS file", FL_CTRL + 's',
			 (Fl_Callback *)openSSPS_cb, this);
	menu->add( "&File/&Clear All", FL_CTRL + 'c',
			 (Fl_Callback *)clear_cb, this ); 
	menu->add( "&File/&Quit", FL_CTRL + 'q',
			 (Fl_Callback *)quit_cb ); 

	/****************************
	* Code generated by FLUID
	***************************/
	
	// Open trace browser
	
	{ Fl_Multi_Browser* o = playerTraceBrowser = new Fl_Multi_Browser(140, 50, 170, 55, "Open traces:");
      playerTraceBrowser->tooltip("Shows the open traces, use the control key to select or deselect multiple traces");
      playerTraceBrowser->box(FL_PLASTIC_THIN_DOWN_BOX);
      playerTraceBrowser->align(FL_ALIGN_TOP);
      o->callback((Fl_Callback*)guiCallback, this);
    } // Fl_Browser* playerTraceBrowser
	
	// Buttons
	{ Fl_Button* o = btnRemove = new Fl_Button(140, 105, 170, 20, "Remove Selected");
      btnRemove->tooltip("Removes the selected trace(s)");
      btnRemove->box(FL_PLASTIC_UP_BOX);
      o->callback((Fl_Callback*)guiCallback, this);
    } // Fl_Button* btnRemove

    { Fl_Light_Button* o = btnLight = new Fl_Light_Button(315, 30, 125, 20, "Light enabled");
      btnLight->tooltip("Toggles the lighting");
      btnLight->box(FL_PLASTIC_UP_BOX);
	  btnLight->value(1);
      o->callback((Fl_Callback*)guiCallback, this);
    } // Fl_Light_Button* btnLight
    { Fl_Light_Button* o = btnAxes = new Fl_Light_Button(315, 50, 125, 20, "Draw axes");
      btnAxes->tooltip("Toggles the display of the XYZ axes");
      btnAxes->box(FL_PLASTIC_UP_BOX);
      btnAxes->value(1);
      o->callback((Fl_Callback*)guiCallback, this);
    } // Fl_Light_Button* btnAxes
    { Fl_Light_Button* o = btnNegative = new Fl_Light_Button(315, 70, 125, 20, "Show negative");
      btnNegative->tooltip("Toggles displaying the negative space regions");
      btnNegative->box(FL_PLASTIC_UP_BOX);
      btnNegative->value(1);
      o->callback((Fl_Callback*)guiCallback, this);
    } // Fl_Light_Button* btnNegative
	{ Fl_Light_Button* o = btnSwapYZ = new Fl_Light_Button(450, 30, 125, 20, "Swap YZ axes");
      btnSwapYZ->tooltip("Swaps the Y and Z axes for the map and the traces");
      btnSwapYZ->box(FL_PLASTIC_UP_BOX);
	  btnSwapYZ->value(1);
      o->callback((Fl_Callback*)guiCallback, this);
    } // Fl_Light_Button* btnSwapYZ
    { Fl_Light_Button* o = btnFlipX = new Fl_Light_Button(450, 50, 125, 20, "Flip X axis");
      btnFlipX->tooltip("Mirror the map and traces on the X axis");
      btnFlipX->box(FL_PLASTIC_UP_BOX);
	  btnFlipX->value(1);
      o->callback((Fl_Callback*)guiCallback, this);
    } // Fl_Light_Button* btnFlipX
	{ Fl_Light_Button* o = btnTrimNegative = new Fl_Light_Button(315, 90, 125, 20, "Trim negative");
      btnTrimNegative->tooltip("Toggles showing only \"floor\" negative spaces");
      btnTrimNegative->box(FL_PLASTIC_UP_BOX);
	  btnTrimNegative->value(1);
      o->callback((Fl_Callback*)guiCallback, this);
    } // Fl_Light_Button* btnTrimNegative
    { Fl_Light_Button* o = btnGateways = new Fl_Light_Button(315, 110, 125, 20, "Draw gateways");
      btnGateways->tooltip("Toggle showing gateways");
      btnGateways->box(FL_PLASTIC_UP_BOX);
      o->callback((Fl_Callback*)guiCallback, this);
    } // Fl_Light_Button* btnGateways
    { Fl_Button* o = btnResetCamera = new Fl_Button(585, 40, 100, 30, "Reset camera");
      btnResetCamera->tooltip("Reset camera to initial position");
      btnResetCamera->box(FL_PLASTIC_UP_BOX);
      btnResetCamera->down_box(FL_PLASTIC_DOWN_BOX);
      o->callback((Fl_Callback*)guiCallback, this);
    } // Fl_Button* btnResetCamera
	
	
    { lblCurrentMap = new Fl_Output(5, 50, 125, 25, "Current map:");
      lblCurrentMap->tooltip("Shows the current SSPS map");
      lblCurrentMap->box(FL_PLASTIC_DOWN_BOX);
      lblCurrentMap->align(FL_ALIGN_TOP_LEFT);
    } // Fl_Output* lblCurrentMap
	
	{ Fl_Value_Slider* o = sldWorldScale = new Fl_Value_Slider(450, 105, 240, 20, "World Scale");
      sldWorldScale->tooltip("Adjust the scale of the map and traces");
      sldWorldScale->type(5);
      sldWorldScale->box(FL_PLASTIC_UP_BOX);
      sldWorldScale->minimum(0.01);
      sldWorldScale->maximum(2);
      sldWorldScale->value(0.05);
      sldWorldScale->align(FL_ALIGN_TOP);
      o->callback((Fl_Callback*)guiCallback, this);
    } // Fl_Value_Slider* sldWorldScale

	// Create the OpenGL drawing area
	glwidget = new GLWidget( 0, 130, WIDTH, HEIGHT, "", playerTraceBrowser, lblCurrentMap);

	if (argc < 5)
	{
	  //get the current path
	  string strFile;
	  string path = string(argv[0]);
	  //find the .app/ in path
	  int appPos = path.rfind(".app/");
	  if (appPos != string::npos)
	  {
		  int slashPos = path.rfind("/",appPos);
		  strFile = path.substr(0,slashPos+1);
	  }
	  currentPath = strFile;
	  //see if the config file is there
	  ifstream ifs((currentPath+"config").c_str());
	  
	  if (ifs)
	  {
		  getline(ifs,lastTracePathChosen);
		  getline(ifs,lastSSPSPathChosen);
	  }
	  else
	  {
		  lastTracePathChosen=currentPath;
		  lastSSPSPathChosen =currentPath;
	  }
	  ifs.close();
	  glwidget->setDataDirectory(strFile.c_str());
	  chooser = new Fl_File_Chooser(lastTracePathChosen.c_str(),"*.data",FL_SINGLE,"Choose a data file");
	  sspsChooser = new Fl_File_Chooser(lastSSPSPathChosen.c_str(),"*.xml",FL_SINGLE,"Choose a SSPS file");
	}
	win->end();
	
	//parse the command line input if there is any
	if (argc >= 3)
	{
	  if (argc == 3)
	  {
		  //pass the .data file
		  glwidget->readDataFile(argv[1],NULL,NULL);
		  glwidget->setImageName(argv[2]);
	  }
	  else if (argc == 4)
	  {
		  //pass the .data file, ssps file, dias file
		  glwidget->readDataFile(argv[1],argv[2],NULL);
		  glwidget->setImageName(argv[3]);
	  }
	  else if (argc == 5)
	  {
		  //pass the .data file, ssps file, dias file
		  glwidget->readDataFile(argv[1],argv[2],argv[3]);
		  glwidget->setImageName(argv[4]);
	  }
	  //set the camera angle
	  glwidget->setCameraAngle(0);
	  glwidget->draw();
	}
}

MainWindow::~MainWindow()
{
	delete chooser;
	
	delete lblCurrentMap;
	delete playerTraceBrowser;
	delete btnLight, btnAxes, btnNegative, btnTrimNegative, btnGateways, btnRemove, btnSwapYZ, btnFlipX;
	delete btnResetCamera;
	delete sldWorldScale;
	
	delete glwidget;
	delete win;
}

void MainWindow::savePathToFile()
{
    ofstream ofs((currentPath+"config").c_str());
    ofs << lastTracePathChosen << endl;
    ofs << lastSSPSPathChosen << endl;
    ofs.close();
}

void MainWindow::show( int argc, char **argv )
{
  // Pass the show() command on to our window
  win->show( argc, argv );
}

void MainWindow::setTitle(const char* title)
{
	win->label(title);
}

void MainWindow::setLastPath(string path)
{
    string strFile;
    int slashPos = path.rfind("/");
    if (slashPos != string::npos)
    {
        strFile = path.substr(0, slashPos+1);
    }
    else
    {
        slashPos = path.rfind("\\");
        if (slashPos != string::npos)
        {
            strFile = path.substr(0, slashPos+1);
        }
        else
        {
            strFile = "";
        }
    }
    //save this path as the last path
    //check which path it is first (check extension)
    if (path.substr(path.length()-3,3) == "xml")
    {
        lastSSPSPathChosen = strFile;
    }
    else
    {
        lastTracePathChosen = strFile;
    }
    //set the path of the chooser
    savePathToFile();
}

string MainWindow::getCurrentPath()
{
    return currentPath;
}

Fl_File_Chooser* MainWindow::getChooser()
{
	return chooser;
}

Fl_File_Chooser* MainWindow::getSSPSChooser()
{
	return sspsChooser;
}

GLWidget* MainWindow::getGLWidget()
{
	return glwidget;
}

void MainWindow::myGuiCallback(Fl_Widget* w)
{
	if (w == btnAxes)
	{
		glwidget->toggleAxes();
	}
	else if (w == btnLight)
	{
		glwidget->toggleLighting();
	}
	else if (w == btnNegative)
	{
		glwidget->toggleNegativeSpace();
	}
	else if (w == btnTrimNegative)
	{
		glwidget->toggleTrimNegative();
	}
	else if (w == btnGateways)
	{
		glwidget->toggleGateways();
	}
	else if (w == btnSwapYZ)
	{
		glwidget->toggleSwapYZ();
	}
	else if (w == btnFlipX)
	{
		glwidget->toggleFlipX();
	}
	else if (w == btnRemove)
	{
		glwidget->removeSelectedTraces();
	}
	else if (w == btnResetCamera)
	{
		glwidget->resetCamera();
	}
	else if (w == playerTraceBrowser)
	{
		glwidget->redraw();
	}
	else if (w == sldWorldScale)
	{
		glwidget->setWorldScale(sldWorldScale->value());
	}
}


