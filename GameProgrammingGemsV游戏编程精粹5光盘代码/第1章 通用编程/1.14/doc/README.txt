This source code is an overview of the theory describe in the article “An Effective Cache-
Oblivious Implementation of the ABT Tree” within the General Programming Section of 
the Game Programming Gems 5 book.


This source code is composed of the following files:

A basic 3D-Vector class:
      vhdVector3.h
      vhdVector3.inl
      vhdVector3.cpp

A basic Axis Aligned Bounding Box class:
      vhdAxisAlignedBox.h

A singleton template:
      vhdSingleton.h

A utility class used to convert more human readable binary trees to cache-oblivious ones:
      vhdSceneConverterABTTree.h
      vhdSceneConverterABTTree.cpp

The Cache-Oblivious ABT Tree itself:
      vhdABTTree.h
      vhdABTTree.cpp

A simple test application:
      test_app.cpp


Building the application:

In order to build the provided source code, you must compile all the above source code 
and ensure that the folder vhdABTTree is in your include path.
This demo was programmed to run under windows operating systems and a workspace 
file for Microsoft Visual C++ 7.1 is included as well as a generic Sconstruct file 
(http://www.scons.org).
Even if the source does not rely on any platform specific routines, it may require minors’ 
changes in order to compile on other platforms.

The purpose of this sample code is not to provide the most optimized version of a cache-
oblivious ABT Tree but rather tend to be more educative and understandable. The source 
code is commented using the doxygen tags (http://www.doxygen.org). Thus, the 
documentation generated is as well provided.

Among the source, you will find an example of the output generated by the test 
application.



What means the different outputs from the test_app?


The first steps in the application are the creation of the tree itself:

// indicate which is the current cache line used  
Current Cache Line Index    : 0 		
// tell which will be the next available cache line. (Some lines are reserved for ensuring 
that sub-trees are direct neighbors)
First Free Cache Line Index : 0

// tell that we are creating a child with his Id. 
Make Children               : 1
Make Children               : 2
Make Children               : 3
Make Children               : 4
Make Children               : 5
Make Children               : 6

// prepare the next sub-trees memory space
Current Cache Line Index    : 1
First Free Cache Line Index : 8

// fill a sub-tree
Make Children               : 9
Make Children               : 10
Make Children               : 11
Make Children               : 12
Make Children               : 13
Make Children               : 14

// and prepare space for his own sub-trees.
Current Cache Line Index    : 9
First Free Cache Line Index : 16

//so on…..

Make Children               : 73
Make Children               : 74
Make Children               : 75
Make Children               : 76
Make Children               : 77
Make Children               : 78
Current Cache Line Index    : 17
First Free Cache Line Index : 24

Make Leaf
Current Child Position      : 137
// indicate that we are creating a leaf with his id and the different elements store in this 
leaf.
Leaf Index                  : 1
Lead ID                     : Leaf Id 0 , Leaf Id 1 , Leaf Id 2

…….
…….
…….
…….


// the second part consist to parse the entire tree and to describe each leaf as soon as they 
get visited:

Complete Search

//describe his position in the array
Leaf at Position           : 137
//tell the leaf index 
Leaf Index                  : 0
// and element attach to it
Lead ID                     :  Leaf Id 0 , Leaf Id 1 , Leaf Id 2

Leaf at Position            : 138
Leaf Index                  : 1
Lead ID                     : Leaf Id 3 , Leaf Id 4 , Leaf Id 5 , Leaf Id 6

Leaf at Position            : 145
Leaf Index                  : 2
Lead ID                     : Leaf Id 7 , Leaf Id 8 , Leaf Id 9 , Leaf Id 10

…….
…….


Complete Search: number of leaves visited 3202


// the test app is doing a second traversal, using a randomize methods to decide if a local 
bounding box is visible or not


Random Search

Leaf at Position            : 137
Leaf Index                  : 0
Lead ID                     : Leaf Id 0 , Leaf Id 1 , Leaf Id 2

Leaf at Position            : 138
Leaf Index                  : 1
Lead ID                     : Leaf Id 3 , Leaf Id 4 , Leaf Id 5 , Leaf Id 6

……
……
Random Search : number of leaves visited 740


// and finally a final complete traversal:

Complete Search

Leaf at Position            : 137
Leaf Index                  : 0
Lead ID                     : Leaf Id 0 , Leaf Id 1 , Leaf Id 2

Leaf at Position            : 138
Leaf Index                  : 1
Lead ID                     : Leaf Id 3 , Leaf Id 4 , Leaf Id 5 , Leaf Id 6

……
……

Complete Search: Number of Leaves Visited 3202





The author would appreciate to receive any feedbacks (questions or remarks) either 
from the article or the companion source code you may have.
Please, feel free to reached me at this address: Sebastien.Schertenleib@epfl.ch 

Enjoy and thank you!

Sébastien Schertenleib


