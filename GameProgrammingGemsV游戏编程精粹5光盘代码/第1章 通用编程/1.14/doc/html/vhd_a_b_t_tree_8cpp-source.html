<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>vhdABTTree: vhdABTTree.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.8 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<h1>vhdABTTree.cpp</h1><pre class="fragment"><div>00001 
00002 <span class="comment">//      Copyright : Sebastien Schertenleib</span>
00003 <span class="comment">//                : VRLab-EPFL</span>
00004 <span class="comment">//</span>
00005 <span class="comment">//      Email :Sebastien.Schertenleib@epfl.ch</span>
00006 <span class="comment">//</span>
00007 <span class="comment">//      This source code is a part of the Game Programming Gems 5 Source Code</span>
00008 <span class="comment">//</span>
00009 <span class="comment">//  Permission to copy, modify, reproduce or redistribute this source code is</span>
00010 <span class="comment">//  granted provided the above copyright notice is retained in the resulting </span>
00011 <span class="comment">//  source code.</span>
00012 <span class="comment">//</span>
00013 <span class="comment">//      This file is provided 'as is' with no expressed or implied warranty.</span>
00014 <span class="comment">//      The author accepts no liability if it causes any damage to your computer.</span>
00015 <span class="comment">//</span>
00016 <span class="comment">//      Do expect bugs.</span>
00017 <span class="comment">//      Please let me know of any bugs/mods/improvements.</span>
00018 <span class="comment">//      and I will try to fix/incorporate them into this file.</span>
00019 <span class="comment">//      Enjoy!</span>
00020 <span class="comment">//</span>
00022 <span class="comment"></span>
00023 
00024 
00025 <span class="preprocessor">#include "vhdABTTree.h"</span>
00026 <span class="preprocessor">#include "vhdSceneConverterABTTree.h"</span>
00027 
00028 <span class="preprocessor">#include &lt;iostream&gt;</span>
00029 <span class="preprocessor">#include &lt;math.h&gt;</span>
00030 
00031 <span class="preprocessor">#define BITLEAF 0</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#define LX 1</span>
00033 <span class="preprocessor"></span><span class="preprocessor">#define LY 2</span>
00034 <span class="preprocessor"></span><span class="preprocessor">#define LZ 3</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#define RX 4</span>
00036 <span class="preprocessor"></span><span class="preprocessor">#define RY 5</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#define RZ 6</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#define BITFLAG 7</span>
00039 <span class="preprocessor"></span>
00040 <span class="preprocessor">#define MASK_ISLEAF 0x01</span>
00041 <span class="preprocessor"></span><span class="preprocessor">#define MASK_NULL       0x00</span>
00042 <span class="preprocessor"></span><span class="preprocessor">#define MASK_LX         0x80 </span>
00043 <span class="preprocessor"></span><span class="preprocessor">#define MASK_LY         0x40 </span>
00044 <span class="preprocessor"></span><span class="preprocessor">#define MASK_LZ         0x20 </span>
00045 <span class="preprocessor"></span><span class="preprocessor">#define MASK_RX         0x10 </span>
00046 <span class="preprocessor"></span><span class="preprocessor">#define MASK_RY         0x08 </span>
00047 <span class="preprocessor"></span><span class="preprocessor">#define MASK_RZ         0x04 </span>
00048 <span class="preprocessor"></span><span class="preprocessor">#define MASK_LL         0x02 </span>
00049 <span class="preprocessor"></span><span class="preprocessor">#define MASK_RL         0x01 </span>
00050 <span class="preprocessor"></span>
00051 
00052 
00053 
00054 uint32 
00055 vhdABTTree::_computeSubTreeDepth()
00056 {
00057         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nResult(0);
00058         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nCur(vhdABTTree::nCacheLineBytes);
00059         nCur/=4 ;
00060         <span class="keywordflow">while</span> (nCur &gt; 2)
00061         {
00062                 <span class="comment">//we divide in two</span>
00063                 nCur/=2 ;
00064                 ++nResult;
00065         }
00066         <span class="keywordflow">return</span> nResult;
00067 }
00068 
00069 <span class="comment">//set up memory structure constants</span>
00070 <span class="preprocessor">#define ABTTREE_CACHE_LINE_BYTES 64</span>
00071 <span class="preprocessor"></span>
00072 uint32 vhdABTTree::nCacheLineBytes = ABTTREE_CACHE_LINE_BYTES;
00073 uint32 vhdABTTree::nCacheLineNodes = vhdABTTree::nCacheLineBytes / <span class="keyword">sizeof</span>(<a class="code" href="unionvhd_a_b_t_tree_node.html">vhdABTTreeNode</a>);
00074 uint32 vhdABTTree::nDepth=vhdABTTree::_computeSubTreeDepth();
00075 uint32 vhdABTTree::nSubTreeId = pow(2,vhdABTTree::nDepth-1) -1;
00076 <span class="keyword">const</span> uint32 vhdABTTree::nArrayDeep = 180;
00077 
00078 
00079 
00080 
00081 <span class="keywordtype">void</span> 
00082 vhdABTTree::visit(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> uiCurrentPos, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> uiIndex, <span class="keyword">const</span> <a class="code" href="classvhd_axis_aligned_box.html">vhdAxisAlignedBox</a> &amp;bbox)
00083 {
00084         <span class="keywordflow">return</span>;
00085 }
00086 
00087 
<a name="l00088"></a><a class="code" href="classvhd_a_b_t_tree.html#a0">00088</a> <a class="code" href="classvhd_a_b_t_tree.html#a0">vhdABTTree::vhdABTTree</a>()
00089 {
00090         
00091         _nFirstFreeCacheLineIndex = 0;
00092         _nLeafIndex = 0;
00093         <a class="code" href="classvhd_a_b_t_tree.html#o0">funcIsVisible</a>= vhdABTTree::_isVisible;
00094         <a class="code" href="classvhd_a_b_t_tree.html#o1">funcVisit</a> = vhdABTTree::visit;
00095 }
00096 
00097 
00098 <span class="keywordtype">void</span>
<a name="l00099"></a><a class="code" href="classvhd_a_b_t_tree.html#a2">00099</a> <a class="code" href="classvhd_a_b_t_tree.html#a2">vhdABTTree::create</a>(uint32 nObjects)
00100 {
00101         _nFirstFreeCacheLineIndex = 0;
00102         nCacheLines = nObjects * vhdABTTree::nArrayDeep / nCacheLineNodes + 1;
00103         
00104         uint32 maxFreeNodes = vhdABTTree::nCacheLines * (vhdABTTree::nCacheLineNodes + 1);
00105         _pNode= <span class="keyword">new</span> <a class="code" href="unionvhd_a_b_t_tree_node.html">vhdABTTreeNode</a>[maxFreeNodes];
00106         memset(_pNode,0,maxFreeNodes*<span class="keyword">sizeof</span>(vhdABTTreeNode));
00107         
00108         _pLeaf = <span class="keyword">new</span> <a class="code" href="classvhd_a_b_t_tree_leaf.html">vhdABTTreeLeaf</a>[nObjects];
00109         _nLeafIndex = 0;
00110 
00111         <a class="code" href="classvhd_axis_aligned_box.html">vhdAxisAlignedBox</a> boxLeft;
00112         <a class="code" href="classvhd_axis_aligned_box.html">vhdAxisAlignedBox</a> boxRight;
00113         
00114         <span class="comment">//we are looking for getting the absolute bounding box.</span>
00115         <span class="comment">//id 0 contains all geometry</span>
00116         vhdSceneConverterABTTree::getSingleton().<a class="code" href="classvhd_scene_converter_a_b_t_tree.html#a2">getChildren</a>(vhdSceneConverterABTTree::getSingleton().pDataRootNode ,0, boxLeft, boxRight);
00117         _bbox = vhdSceneConverterABTTree::getSingleton().<a class="code" href="classvhd_scene_converter_a_b_t_tree.html#e0">findGlobalAABB</a>(vhdSceneConverterABTTree::getSingleton().pDataRootNode-&gt;listAABB);
00118         
00119         _makeNodeDataFlags(0,_bbox,boxLeft, boxRight);
00120         
00121         <span class="comment">//go with the build</span>
00122         subTreeBuild(0, _bbox);
00123 }
00124 
00125 <span class="keywordtype">void</span>
<a name="l00126"></a><a class="code" href="classvhd_a_b_t_tree.html#a4">00126</a> <a class="code" href="classvhd_a_b_t_tree.html#a4">vhdABTTree::destroy</a>()
00127 {
00128         <span class="keyword">delete</span>[] _pLeaf;
00129         <span class="keyword">delete</span>[] _pNode;
00130 }
00131 
00132 <span class="keywordtype">void</span>
<a name="l00133"></a><a class="code" href="classvhd_a_b_t_tree.html#a3">00133</a> <a class="code" href="classvhd_a_b_t_tree.html#a2">vhdABTTree::create</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nCacheLineSize, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nLeafSize  )
00134 {
00135         _nFirstFreeCacheLineIndex = 0;
00136         nCacheLines = nCacheLineSize;
00137         
00138         _pNode= <span class="keyword">new</span> <a class="code" href="unionvhd_a_b_t_tree_node.html">vhdABTTreeNode</a>[nCacheLineSize];
00139         
00140         _pLeaf = <span class="keyword">new</span> <a class="code" href="classvhd_a_b_t_tree_leaf.html">vhdABTTreeLeaf</a>[nLeafSize];
00141         _nLeafIndex = nLeafSize;
00142 }
00143 
00144 
00145 byte
00146 vhdABTTree::_extendLeft(<span class="keywordtype">float</span> fMinExtend, <span class="keywordtype">float</span> fMinParent, <span class="keywordtype">float</span> fMaxParent)
00147 {
00148         <span class="keywordflow">return</span> (byte) (255* (   (fMinExtend - fMinParent) / ( fMaxParent - fMinParent ) ) );
00149 }
00150 byte
00151 vhdABTTree::_extendRight(<span class="keywordtype">float</span> fMaxExtend, <span class="keywordtype">float</span> fMinParent, <span class="keywordtype">float</span> fMaxParent)
00152 {
00153         <span class="keywordflow">return</span> (byte) (255* (   ( fMaxParent - fMaxExtend ) / ( fMaxParent - fMinParent ) ) );
00154 }
00155 
00156 <span class="keywordtype">void</span> 
00157 vhdABTTree::_makeNodeDataFlags(uint32 nCurrentChildPosition, <span class="keyword">const</span> <a class="code" href="classvhd_axis_aligned_box.html">vhdAxisAlignedBox</a> &amp;box, <span class="keyword">const</span> <a class="code" href="classvhd_axis_aligned_box.html">vhdAxisAlignedBox</a> &amp;boxLeft, <span class="keyword">const</span> <a class="code" href="classvhd_axis_aligned_box.html">vhdAxisAlignedBox</a> &amp; boxRight)
00158 {
00159         <a class="code" href="classvhd_vector3.html">vhdVector3</a> minBox  = box.<a class="code" href="classvhd_axis_aligned_box.html#a2">getMinimum</a>();
00160         <a class="code" href="classvhd_vector3.html">vhdVector3</a> maxBox  = box.<a class="code" href="classvhd_axis_aligned_box.html#a3">getMaximum</a>();
00161         
00162         <a class="code" href="classvhd_vector3.html">vhdVector3</a> minBoxLeft = boxLeft.<a class="code" href="classvhd_axis_aligned_box.html#a2">getMinimum</a>();
00163         <a class="code" href="classvhd_vector3.html">vhdVector3</a> maxBoxLeft = boxLeft.<a class="code" href="classvhd_axis_aligned_box.html#a3">getMaximum</a>();
00164         <a class="code" href="classvhd_vector3.html">vhdVector3</a> minBoxRight = boxRight.<a class="code" href="classvhd_axis_aligned_box.html#a2">getMinimum</a>();
00165         <a class="code" href="classvhd_vector3.html">vhdVector3</a> maxBoxRight = boxRight.<a class="code" href="classvhd_axis_aligned_box.html#a3">getMaximum</a>();
00166 
00167 <span class="preprocessor">        #ifdef TREE_DEBUG</span>
00168 <span class="preprocessor"></span>        std::cout &lt;&lt; <span class="stringliteral">"vhdABTTree::_makeNodeDataFlags "</span> &lt;&lt; box &lt;&lt; <span class="stringliteral">"  "</span> &lt;&lt; boxLeft &lt;&lt; <span class="stringliteral">"  "</span> &lt;&lt; boxRight &lt;&lt; std::endl;
00169 <span class="preprocessor">        #endif</span>
00170 <span class="preprocessor"></span>
00171         <span class="keywordflow">if</span> (minBox.<a class="code" href="classvhd_vector3.html#o0">x</a> == minBoxLeft.<a class="code" href="classvhd_vector3.html#o0">x</a>)
00172         {
00173                 _pNode[nCurrentChildPosition].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[BITFLAG] = _pNode[nCurrentChildPosition].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[BITFLAG] |  MASK_LX;
00174                 _pNode[nCurrentChildPosition].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[LX] = _extendLeft(minBoxRight.<a class="code" href="classvhd_vector3.html#o0">x</a>, minBox.<a class="code" href="classvhd_vector3.html#o0">x</a>, maxBox.<a class="code" href="classvhd_vector3.html#o0">x</a>);
00175         }
00176         <span class="keywordflow">else</span>
00177         {
00178                 _pNode[nCurrentChildPosition].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[LX] = _extendLeft(minBoxLeft.<a class="code" href="classvhd_vector3.html#o0">x</a>, minBox.<a class="code" href="classvhd_vector3.html#o0">x</a>, maxBox.<a class="code" href="classvhd_vector3.html#o0">x</a>);
00179         }
00180         <span class="keywordflow">if</span> (minBox.<a class="code" href="classvhd_vector3.html#o1">y</a> ==  minBoxLeft.<a class="code" href="classvhd_vector3.html#o1">y</a>)
00181         {
00182                 _pNode[nCurrentChildPosition].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[BITFLAG] = _pNode[nCurrentChildPosition].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[BITFLAG] |  MASK_LY;
00183                 _pNode[nCurrentChildPosition].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[LY] = _extendLeft(minBoxRight.<a class="code" href="classvhd_vector3.html#o1">y</a>, minBox.<a class="code" href="classvhd_vector3.html#o1">y</a>, maxBox.<a class="code" href="classvhd_vector3.html#o1">y</a>);
00184         }
00185         <span class="keywordflow">else</span>
00186         {
00187                 _pNode[nCurrentChildPosition].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[LY] = _extendLeft(minBoxLeft.<a class="code" href="classvhd_vector3.html#o1">y</a>, minBox.<a class="code" href="classvhd_vector3.html#o1">y</a>, maxBox.<a class="code" href="classvhd_vector3.html#o1">y</a>);
00188         }
00189         <span class="keywordflow">if</span> (minBox.<a class="code" href="classvhd_vector3.html#o2">z</a> ==  minBoxLeft.<a class="code" href="classvhd_vector3.html#o2">z</a>)
00190         {
00191                 _pNode[nCurrentChildPosition].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[BITFLAG] = _pNode[nCurrentChildPosition].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[BITFLAG] |  MASK_LZ;
00192                 _pNode[nCurrentChildPosition].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[LZ] = _extendLeft(minBoxRight.<a class="code" href="classvhd_vector3.html#o2">z</a>, minBox.<a class="code" href="classvhd_vector3.html#o2">z</a>, maxBox.<a class="code" href="classvhd_vector3.html#o2">z</a>);
00193         }
00194         <span class="keywordflow">else</span>
00195         {
00196                 _pNode[nCurrentChildPosition].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[LZ] = _extendLeft(minBoxLeft.<a class="code" href="classvhd_vector3.html#o2">z</a>, minBox.<a class="code" href="classvhd_vector3.html#o2">z</a>, maxBox.<a class="code" href="classvhd_vector3.html#o2">z</a>);
00197         }
00198         <span class="keywordflow">if</span> (maxBox.<a class="code" href="classvhd_vector3.html#o0">x</a> ==  maxBoxLeft.<a class="code" href="classvhd_vector3.html#o0">x</a>)
00199         {
00200                 _pNode[nCurrentChildPosition].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[BITFLAG] = _pNode[nCurrentChildPosition].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[BITFLAG] |  MASK_RX;
00201                 _pNode[nCurrentChildPosition].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[RX] = _extendRight(maxBoxRight.<a class="code" href="classvhd_vector3.html#o0">x</a>,  minBox.<a class="code" href="classvhd_vector3.html#o0">x</a>, maxBox.<a class="code" href="classvhd_vector3.html#o0">x</a>);
00202         }
00203         <span class="keywordflow">else</span>
00204         {
00205                 _pNode[nCurrentChildPosition].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[RX] =  _extendRight(maxBoxLeft.<a class="code" href="classvhd_vector3.html#o0">x</a>,  minBox.<a class="code" href="classvhd_vector3.html#o0">x</a>, maxBox.<a class="code" href="classvhd_vector3.html#o0">x</a>);
00206         }
00207         <span class="keywordflow">if</span> (maxBox.<a class="code" href="classvhd_vector3.html#o1">y</a> ==  maxBoxLeft.<a class="code" href="classvhd_vector3.html#o1">y</a>)
00208         {
00209                 _pNode[nCurrentChildPosition].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[BITFLAG] = _pNode[nCurrentChildPosition].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[BITFLAG] |  MASK_RY;
00210                 _pNode[nCurrentChildPosition].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[RY] = _extendRight(maxBoxRight.<a class="code" href="classvhd_vector3.html#o1">y</a>,  minBox.<a class="code" href="classvhd_vector3.html#o1">y</a>, maxBox.<a class="code" href="classvhd_vector3.html#o1">y</a>);
00211         }
00212         <span class="keywordflow">else</span>
00213         {
00214                 _pNode[nCurrentChildPosition].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[RY] = _extendRight(maxBoxLeft.<a class="code" href="classvhd_vector3.html#o1">y</a>,  minBox.<a class="code" href="classvhd_vector3.html#o1">y</a>, maxBox.<a class="code" href="classvhd_vector3.html#o1">y</a>);
00215         }
00216         <span class="keywordflow">if</span> (maxBox.<a class="code" href="classvhd_vector3.html#o2">z</a> ==  maxBoxLeft.<a class="code" href="classvhd_vector3.html#o2">z</a>)
00217         {
00218                 _pNode[nCurrentChildPosition].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[BITFLAG] = _pNode[nCurrentChildPosition].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[BITFLAG] |  MASK_RZ;
00219                 _pNode[nCurrentChildPosition].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[RZ] = _extendRight(maxBoxRight.<a class="code" href="classvhd_vector3.html#o2">z</a>,  minBox.<a class="code" href="classvhd_vector3.html#o2">z</a>, maxBox.<a class="code" href="classvhd_vector3.html#o2">z</a>);
00220         }
00221         <span class="keywordflow">else</span>
00222         {
00223                 _pNode[nCurrentChildPosition].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[RZ] = _extendRight(maxBoxLeft.<a class="code" href="classvhd_vector3.html#o2">z</a>,  minBox.<a class="code" href="classvhd_vector3.html#o2">z</a>, maxBox.<a class="code" href="classvhd_vector3.html#o2">z</a>);
00224         }
00225 
00226         _pNode[nCurrentChildPosition].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[BITLEAF] = MASK_NULL;
00227 }
00228                 
00229 
00230 
00231 <span class="keywordtype">void</span>
00232 vhdABTTree::_makeChildren(ListElement &amp; listElement, <span class="keyword">const</span> <a class="code" href="classvhd_axis_aligned_box.html">vhdAxisAlignedBox</a> &amp;box, uint32 nCurrentPosition,uint32 nCurrentChildPosition, uint32 index, <span class="keywordtype">bool</span> bLeft )
00233 {
00234         <span class="comment">//get the two box bbox.</span>
00235         <a class="code" href="classvhd_axis_aligned_box.html">vhdAxisAlignedBox</a> boxLeft,boxRight; 
00236         
00237         vhdSceneConverterABTTree::vhdSceneABTTreeNode *pCurNode= NULL;
00238         <span class="keywordflow">if</span> (bLeft) 
00239         {
00240                 pCurNode=vhdSceneConverterABTTree::getSingleton().<a class="code" href="classvhd_scene_converter_a_b_t_tree.html#o0">mapNodeChild</a>[nCurrentPosition].pLeft;
00241         }
00242         <span class="keywordflow">else</span>
00243         {
00244                 pCurNode=vhdSceneConverterABTTree::getSingleton().<a class="code" href="classvhd_scene_converter_a_b_t_tree.html#o0">mapNodeChild</a>[nCurrentPosition].pRight;
00245         }
00246         pCurNode-&gt;pLeft=pCurNode-&gt;pRight=NULL;
00247         
00248         std::cout &lt;&lt; <span class="stringliteral">"Make Children               : "</span> &lt;&lt; nCurrentChildPosition &lt;&lt; std::endl;
00249         
00250         vhdSceneConverterABTTree::getSingleton().<a class="code" href="classvhd_scene_converter_a_b_t_tree.html#a2">getChildren</a>(pCurNode ,nCurrentChildPosition,boxLeft, boxRight);
00251         
00252         
00253         _makeNodeDataFlags(nCurrentChildPosition, box, boxLeft,boxRight); 
00254         listElement.push_back(Element(index, box));     
00255 }
00256 
00257 
00258 
00259 <span class="keywordtype">void</span>
00260 vhdABTTree::_makeLeaf(uint32 nCurrentPosition,uint32 nCurrentChildPosition ,<span class="keywordtype">bool</span> bLeft)
00261 {
00262         _pNode[nCurrentChildPosition].<a class="code" href="unionvhd_a_b_t_tree_node.html#o0">leaf</a>.<a class="code" href="classvhd_a_b_t_tree_leaf_data.html#o0">index</a> = _nLeafIndex &lt;&lt; MASK_ISLEAF;
00263         _pNode[nCurrentChildPosition].<a class="code" href="unionvhd_a_b_t_tree_node.html#o0">leaf</a>.<a class="code" href="classvhd_a_b_t_tree_leaf_data.html#o0">index</a> = _pNode[nCurrentChildPosition].<a class="code" href="unionvhd_a_b_t_tree_node.html#o0">leaf</a>.<a class="code" href="classvhd_a_b_t_tree_leaf_data.html#o0">index</a> | MASK_ISLEAF;
00264         _pNode[nCurrentChildPosition].<a class="code" href="unionvhd_a_b_t_tree_node.html#o0">leaf</a>.<a class="code" href="classvhd_a_b_t_tree_leaf_data.html#o1">callback</a> = NULL;
00265         ++_nLeafIndex;
00266 
00267 
00268         <span class="comment">//we insert the current status in our map set to null so means leaf!!!</span>
00269         vhdSceneConverterABTTree::vhdSceneABTTreeNode data;
00270         <span class="keywordflow">if</span> (bLeft)
00271         {
00272                 data.listAABB = vhdSceneConverterABTTree::getSingleton().<a class="code" href="classvhd_scene_converter_a_b_t_tree.html#o0">mapNodeChild</a>[nCurrentPosition].pLeft-&gt;listAABB;
00273         }
00274         <span class="keywordflow">else</span>
00275         {
00276                 data.listAABB = vhdSceneConverterABTTree::getSingleton().<a class="code" href="classvhd_scene_converter_a_b_t_tree.html#o0">mapNodeChild</a>[nCurrentPosition].pRight-&gt;listAABB;
00277         }
00278         data.pLeft   = NULL;
00279         data.pRight  = NULL;
00280 
00281         std::cout &lt;&lt; <span class="stringliteral">"Make Leaf"</span> &lt;&lt; std::endl;
00282         std::cout &lt;&lt; <span class="stringliteral">"Current Child Position      : "</span> &lt;&lt; nCurrentChildPosition &lt;&lt;  std::endl;
00283         std::cout &lt;&lt; <span class="stringliteral">"Leaf Index                  : "</span> &lt;&lt; _nLeafIndex &lt;&lt; std::endl;
00284         std::cout &lt;&lt; <span class="stringliteral">"Lead ID                     : "</span>; 
00285         <span class="comment">//loop</span>
00286         vhdSceneConverterABTTree::ListAABB::iterator it = data.listAABB.begin();
00287         std::cout &lt;&lt; it-&gt;strPath;
00288         ++it;
00289         <span class="keywordflow">for</span> ( it; it!= data.listAABB.end(); ++it)
00290         {
00291                 std::cout &lt;&lt; <span class="stringliteral">" , "</span> &lt;&lt; it-&gt;strPath;
00292         }
00293         std::cout &lt;&lt; std::endl &lt;&lt; std::endl;
00294         
00295         vhdSceneConverterABTTree::getSingleton().<a class="code" href="classvhd_scene_converter_a_b_t_tree.html#o0">mapNodeChild</a>.insert(vhdSceneConverterABTTree::MapNodeChild::value_type(nCurrentChildPosition,data));
00296 }
00297 
00298 
00299 <span class="keywordtype">bool</span> 
00300 vhdABTTree::_needToSplit(<span class="keyword">const</span> <a class="code" href="classvhd_axis_aligned_box.html">vhdAxisAlignedBox</a> &amp;box, uint32 nCurrentPos, <span class="keywordtype">bool</span> bLeft)
00301 {
00302         <span class="comment">//we check with this companion methods</span>
00303         vhdSceneConverterABTTree::vhdSceneABTTreeNode *pCurNode= NULL;
00304         <span class="keywordflow">if</span> (bLeft) 
00305         {
00306                 pCurNode=vhdSceneConverterABTTree::getSingleton().<a class="code" href="classvhd_scene_converter_a_b_t_tree.html#o0">mapNodeChild</a>[nCurrentPos].pLeft;
00307         }
00308         <span class="keywordflow">else</span>
00309         {
00310                 pCurNode=vhdSceneConverterABTTree::getSingleton().<a class="code" href="classvhd_scene_converter_a_b_t_tree.html#o0">mapNodeChild</a>[nCurrentPos].pRight;
00311         }
00312         
00313         <span class="keywordflow">if</span> (pCurNode )
00314         {
00315                 <span class="comment">//2 for each sub-node (left/right)</span>
00316                 <span class="keywordflow">if</span>(pCurNode-&gt;listAABB.size()&gt;4) 
00317                 {
00318                         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00319                 }
00320         }       
00321         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00322 }
00323 
00324 
00325 
00326 <span class="keywordtype">void</span>
00327 vhdABTTree::_computeChildBox(<span class="keyword">const</span> <a class="code" href="classvhd_axis_aligned_box.html">vhdAxisAlignedBox</a> &amp; boxParent, <a class="code" href="classvhd_axis_aligned_box.html">vhdAxisAlignedBox</a> &amp;boxLeft,<a class="code" href="classvhd_axis_aligned_box.html">vhdAxisAlignedBox</a> &amp;boxRight, uint32 nCurrentPos )
00328 {
00329         <a class="code" href="classvhd_vector3.html">vhdVector3</a> vecMinParent = boxParent.<a class="code" href="classvhd_axis_aligned_box.html#a2">getMinimum</a>();
00330         <a class="code" href="classvhd_vector3.html">vhdVector3</a> vecMaxParent = boxParent.<a class="code" href="classvhd_axis_aligned_box.html#a3">getMaximum</a>();
00331         <a class="code" href="classvhd_vector3.html">vhdVector3</a> vecMinLeft, vecMinRight, vecMaxLeft, vecMaxRight;
00332 
00333         
00334         <span class="keywordflow">if</span> ( (_pNode[nCurrentPos].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[BITFLAG] &amp;  MASK_LX) == MASK_LX)
00335         {
00336                  <span class="comment">//mean that the left children take the parent value</span>
00337                 vecMinLeft.<a class="code" href="classvhd_vector3.html#o0">x</a> = vecMinParent.<a class="code" href="classvhd_vector3.html#o0">x</a>;
00338                 vecMinRight.<a class="code" href="classvhd_vector3.html#o0">x</a> = ((<span class="keywordtype">float</span>)(_pNode[nCurrentPos].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[LX])/255.0f) * (vecMaxParent.<a class="code" href="classvhd_vector3.html#o0">x</a>-vecMinParent.<a class="code" href="classvhd_vector3.html#o0">x</a>) + vecMinParent.<a class="code" href="classvhd_vector3.html#o0">x</a>;
00339         }
00340         <span class="keywordflow">else</span>
00341         {
00342                 <span class="comment">//left is parent</span>
00343                 vecMinRight.<a class="code" href="classvhd_vector3.html#o0">x</a> = vecMinParent.<a class="code" href="classvhd_vector3.html#o0">x</a>;
00344                 vecMinLeft.<a class="code" href="classvhd_vector3.html#o0">x</a> = ((<span class="keywordtype">float</span>)(_pNode[nCurrentPos].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[LX])/255.0f) * (vecMaxParent.<a class="code" href="classvhd_vector3.html#o0">x</a>-vecMinParent.<a class="code" href="classvhd_vector3.html#o0">x</a>) + vecMinParent.<a class="code" href="classvhd_vector3.html#o0">x</a>;
00345         }
00346 
00347         <span class="keywordflow">if</span> ((_pNode[nCurrentPos].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[BITFLAG] &amp;  MASK_LY) == MASK_LY)
00348         {
00349                 <span class="comment">//mean that the left children take the parent value</span>
00350                 vecMinLeft.<a class="code" href="classvhd_vector3.html#o1">y</a> = vecMinParent.<a class="code" href="classvhd_vector3.html#o1">y</a>;
00351                 vecMinRight.<a class="code" href="classvhd_vector3.html#o1">y</a> = ((<span class="keywordtype">float</span>)(_pNode[nCurrentPos].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[LY])/255.0f) * (vecMaxParent.<a class="code" href="classvhd_vector3.html#o1">y</a>-vecMinParent.<a class="code" href="classvhd_vector3.html#o1">y</a>) + vecMinParent.<a class="code" href="classvhd_vector3.html#o1">y</a>;
00352         }
00353         <span class="keywordflow">else</span>
00354         {
00355                 <span class="comment">//left is parent</span>
00356                 vecMinRight.<a class="code" href="classvhd_vector3.html#o1">y</a> = vecMinParent.<a class="code" href="classvhd_vector3.html#o1">y</a>;
00357                 vecMinLeft.<a class="code" href="classvhd_vector3.html#o1">y</a> = ((<span class="keywordtype">float</span>)(_pNode[nCurrentPos].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[LY])/255.0f) * (vecMaxParent.<a class="code" href="classvhd_vector3.html#o1">y</a>-vecMinParent.<a class="code" href="classvhd_vector3.html#o1">y</a>) + vecMinParent.<a class="code" href="classvhd_vector3.html#o1">y</a>;
00358         }
00359 
00360         <span class="keywordflow">if</span> ((_pNode[nCurrentPos].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[BITFLAG] &amp;  MASK_LZ) == MASK_LZ)
00361         {
00362                  <span class="comment">//mean that the left children take the parent value</span>
00363                 vecMinLeft.<a class="code" href="classvhd_vector3.html#o2">z</a> = vecMinParent.<a class="code" href="classvhd_vector3.html#o2">z</a>;
00364                 vecMinRight.<a class="code" href="classvhd_vector3.html#o2">z</a> = ((<span class="keywordtype">float</span>)(_pNode[nCurrentPos].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[LZ])/255.0f) * (vecMaxParent.<a class="code" href="classvhd_vector3.html#o2">z</a>-vecMinParent.<a class="code" href="classvhd_vector3.html#o2">z</a>) + vecMinParent.<a class="code" href="classvhd_vector3.html#o2">z</a>;
00365         }
00366         <span class="keywordflow">else</span>
00367         {
00368                 <span class="comment">//left is parent</span>
00369                 vecMinRight.<a class="code" href="classvhd_vector3.html#o2">z</a> = vecMinParent.<a class="code" href="classvhd_vector3.html#o2">z</a>;
00370                 vecMinLeft.<a class="code" href="classvhd_vector3.html#o2">z</a> = ((<span class="keywordtype">float</span>)(_pNode[nCurrentPos].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[LZ])/255.0f) * (vecMaxParent.<a class="code" href="classvhd_vector3.html#o2">z</a>-vecMinParent.<a class="code" href="classvhd_vector3.html#o2">z</a>) + vecMinParent.<a class="code" href="classvhd_vector3.html#o2">z</a>;
00371         }
00372 
00373         <span class="keywordflow">if</span> ((_pNode[nCurrentPos].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[BITFLAG] &amp;  MASK_RX) == MASK_RX)
00374         {
00375                 <span class="comment">//mean that the left children take the parent value</span>
00376                 vecMaxLeft.<a class="code" href="classvhd_vector3.html#o0">x</a> = vecMaxParent.<a class="code" href="classvhd_vector3.html#o0">x</a>;
00377                 vecMaxRight.<a class="code" href="classvhd_vector3.html#o0">x</a> = vecMaxParent.<a class="code" href="classvhd_vector3.html#o0">x</a>- ((<span class="keywordtype">float</span>)(_pNode[nCurrentPos].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[RX])/255.0f) * (vecMaxParent.<a class="code" href="classvhd_vector3.html#o0">x</a>-vecMinParent.<a class="code" href="classvhd_vector3.html#o0">x</a>);
00378         }
00379         <span class="keywordflow">else</span>
00380         {
00381                 <span class="comment">//left is parent</span>
00382                 vecMaxRight.<a class="code" href="classvhd_vector3.html#o0">x</a> = vecMaxParent.<a class="code" href="classvhd_vector3.html#o0">x</a>;
00383                 vecMaxLeft.<a class="code" href="classvhd_vector3.html#o0">x</a> = vecMaxParent.<a class="code" href="classvhd_vector3.html#o0">x</a> -((<span class="keywordtype">float</span>)(_pNode[nCurrentPos].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[RX])/255.0f) * (vecMaxParent.<a class="code" href="classvhd_vector3.html#o0">x</a>-vecMinParent.<a class="code" href="classvhd_vector3.html#o0">x</a>);
00384         }
00385 
00386         <span class="keywordflow">if</span> ((_pNode[nCurrentPos].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[BITFLAG] &amp;  MASK_RY)  == MASK_RY)
00387         {
00388                 <span class="comment">//mean that the left children take the parent value</span>
00389                 vecMaxLeft.<a class="code" href="classvhd_vector3.html#o1">y</a> = vecMaxParent.<a class="code" href="classvhd_vector3.html#o1">y</a>;
00390                 vecMaxRight.<a class="code" href="classvhd_vector3.html#o1">y</a> =  vecMaxParent.<a class="code" href="classvhd_vector3.html#o1">y</a>-((<span class="keywordtype">float</span>)(_pNode[nCurrentPos].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[RY])/255.0f) * (vecMaxParent.<a class="code" href="classvhd_vector3.html#o1">y</a>-vecMinParent.<a class="code" href="classvhd_vector3.html#o1">y</a>);
00391         }
00392         <span class="keywordflow">else</span>
00393         {
00394                 <span class="comment">//left is parent</span>
00395                 vecMaxRight.<a class="code" href="classvhd_vector3.html#o1">y</a> = vecMaxParent.<a class="code" href="classvhd_vector3.html#o1">y</a>;
00396                 vecMaxLeft.<a class="code" href="classvhd_vector3.html#o1">y</a> =  vecMaxParent.<a class="code" href="classvhd_vector3.html#o1">y</a> - ((<span class="keywordtype">float</span>)(_pNode[nCurrentPos].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[RY])/255.0f) * (vecMaxParent.<a class="code" href="classvhd_vector3.html#o1">y</a>-vecMinParent.<a class="code" href="classvhd_vector3.html#o1">y</a>);
00397         }
00398 
00399         <span class="keywordflow">if</span> ((_pNode[nCurrentPos].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[BITFLAG] &amp;  MASK_RZ) == MASK_RZ )
00400         {
00401                 <span class="comment">//mean that the left children take the parent value</span>
00402                 vecMaxLeft.<a class="code" href="classvhd_vector3.html#o2">z</a> = vecMaxParent.<a class="code" href="classvhd_vector3.html#o2">z</a>;
00403                 vecMaxRight.<a class="code" href="classvhd_vector3.html#o2">z</a> = vecMaxParent.<a class="code" href="classvhd_vector3.html#o2">z</a> - ((<span class="keywordtype">float</span>)(_pNode[nCurrentPos].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[RZ])/255.0f) * (vecMaxParent.<a class="code" href="classvhd_vector3.html#o2">z</a>-vecMinParent.<a class="code" href="classvhd_vector3.html#o2">z</a>);
00404         }
00405         <span class="keywordflow">else</span>
00406         {
00407                 <span class="comment">//left is parent</span>
00408                 vecMaxRight.<a class="code" href="classvhd_vector3.html#o2">z</a> = vecMaxParent.<a class="code" href="classvhd_vector3.html#o2">z</a>;
00409                 vecMaxLeft.<a class="code" href="classvhd_vector3.html#o2">z</a> = vecMaxParent.<a class="code" href="classvhd_vector3.html#o2">z</a> - ((<span class="keywordtype">float</span>)(_pNode[nCurrentPos].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[RZ])/255.0f) * (vecMaxParent.<a class="code" href="classvhd_vector3.html#o2">z</a>-vecMinParent.<a class="code" href="classvhd_vector3.html#o2">z</a>) ;
00410         }
00411 
00412         <span class="comment">//at this time we have both vhdAxisAlignedBox</span>
00413         <span class="keywordflow">if</span> (vecMinLeft.<a class="code" href="classvhd_vector3.html#o0">x</a>&gt;vecMaxLeft.<a class="code" href="classvhd_vector3.html#o0">x</a>)
00414         {
00415                 std::swap(vecMinLeft.<a class="code" href="classvhd_vector3.html#o0">x</a>,vecMaxLeft.<a class="code" href="classvhd_vector3.html#o0">x</a>);
00416         }
00417         <span class="keywordflow">if</span> (vecMinLeft.<a class="code" href="classvhd_vector3.html#o1">y</a>&gt;vecMaxLeft.<a class="code" href="classvhd_vector3.html#o1">y</a>)
00418         {
00419                 std::swap(vecMinLeft.<a class="code" href="classvhd_vector3.html#o1">y</a>,vecMaxLeft.<a class="code" href="classvhd_vector3.html#o1">y</a>);
00420         }
00421         <span class="keywordflow">if</span> (vecMinLeft.<a class="code" href="classvhd_vector3.html#o2">z</a>&gt;vecMaxLeft.<a class="code" href="classvhd_vector3.html#o2">z</a>)
00422         {
00423                 std::swap(vecMinLeft.<a class="code" href="classvhd_vector3.html#o2">z</a>,vecMaxLeft.<a class="code" href="classvhd_vector3.html#o2">z</a>);
00424         }
00425         <span class="keywordflow">if</span> (vecMinRight.<a class="code" href="classvhd_vector3.html#o0">x</a>&gt;vecMaxRight.<a class="code" href="classvhd_vector3.html#o0">x</a>)
00426         {
00427                 std::swap(vecMinRight.<a class="code" href="classvhd_vector3.html#o0">x</a>,vecMaxRight.<a class="code" href="classvhd_vector3.html#o0">x</a>);
00428         }
00429         <span class="keywordflow">if</span> (vecMinRight.<a class="code" href="classvhd_vector3.html#o1">y</a>&gt;vecMaxRight.<a class="code" href="classvhd_vector3.html#o1">y</a>)
00430         {
00431                 std::swap(vecMinRight.<a class="code" href="classvhd_vector3.html#o1">y</a>,vecMaxRight.<a class="code" href="classvhd_vector3.html#o1">y</a>);
00432         }
00433         <span class="keywordflow">if</span> (vecMinRight.<a class="code" href="classvhd_vector3.html#o2">z</a>&gt;vecMaxRight.<a class="code" href="classvhd_vector3.html#o2">z</a>)
00434         {
00435                 std::swap(vecMinRight.<a class="code" href="classvhd_vector3.html#o2">z</a>,vecMaxRight.<a class="code" href="classvhd_vector3.html#o2">z</a>);
00436         }
00437         boxLeft.<a class="code" href="classvhd_axis_aligned_box.html#a4">setExtents</a>(vecMinLeft.<a class="code" href="classvhd_vector3.html#o0">x</a>, vecMinLeft.<a class="code" href="classvhd_vector3.html#o1">y</a>, vecMinLeft.<a class="code" href="classvhd_vector3.html#o2">z</a>, vecMaxLeft.<a class="code" href="classvhd_vector3.html#o0">x</a>, vecMaxLeft.<a class="code" href="classvhd_vector3.html#o1">y</a>, vecMaxLeft.<a class="code" href="classvhd_vector3.html#o2">z</a>);
00438         boxRight.<a class="code" href="classvhd_axis_aligned_box.html#a4">setExtents</a>(vecMinRight.<a class="code" href="classvhd_vector3.html#o0">x</a>, vecMinRight.<a class="code" href="classvhd_vector3.html#o1">y</a>, vecMinRight.<a class="code" href="classvhd_vector3.html#o2">z</a>, vecMaxRight.<a class="code" href="classvhd_vector3.html#o0">x</a>, vecMaxRight.<a class="code" href="classvhd_vector3.html#o1">y</a>, vecMaxRight.<a class="code" href="classvhd_vector3.html#o2">z</a>);
00439                 
00440 }
00441 
00442 
00443 
00444 <span class="keywordtype">void</span>
00445 vhdABTTree::subTreeBuild(uint32 nCurrentCacheLineIndex, <span class="keyword">const</span> <a class="code" href="classvhd_axis_aligned_box.html">vhdAxisAlignedBox</a> &amp;box)
00446 {
00447         std::cout &lt;&lt; <span class="stringliteral">"Current Cache Line Index    : "</span> &lt;&lt; nCurrentCacheLineIndex &lt;&lt; std::endl;
00448         std::cout &lt;&lt; <span class="stringliteral">"First Free Cache Line Index : "</span> &lt;&lt; _nFirstFreeCacheLineIndex &lt;&lt; std::endl;
00449         std::cout &lt;&lt; std::endl;
00450         
00451         <span class="comment">//sub-tree must be like this, their are reference in their local index in the current cache lines</span>
00452         <span class="comment">//                                      1|2</span>
00453         <span class="comment">//                      3|4                             5|6</span>
00454         <span class="comment">//              7|8      9|10    11|12   13|14</span>
00455         
00456         <span class="comment">// 1 solution</span>
00457         <span class="comment">//</span>
00458         <span class="comment">// List = [1]</span>
00459         <span class="comment">//ask for split</span>
00460         <span class="comment">//for each el in list, pop_front() , [ push_children]</span>
00461         <span class="comment">//</span>
00462         <span class="comment">// ex:</span>
00463         <span class="comment">// 1|2                        --&gt; 0</span>
00464         <span class="comment">// 3|4  5|6                                       --&gt; 1 2</span>
00465         <span class="comment">// 5|6 7|8 9|10                         ---&gt; 2 3 4</span>
00466         <span class="comment">// 7|8 9|10 11|12 13|14      --&gt; 3 4 5 6</span>
00467         <span class="comment">// 9|10 11|12 13|14          --&gt; 4 5 6 </span>
00468         <span class="comment">// 11|12 13|14                           --&gt; 5 6</span>
00469         <span class="comment">// 13|14                                        --&gt; 6</span>
00470 
00471 
00472         ListElement listElement;
00473         listElement.push_back(Element(0,box));
00474 
00475         <span class="keywordflow">while</span> (listElement.size()&gt;0)
00476         {
00477                 <span class="comment">//check if we are not at the last line of the sub-tree</span>
00478                 <span class="keywordflow">if</span> ( listElement.begin()-&gt;id &gt;= nSubTreeId)
00479                 {
00480                         <span class="comment">//we reach the end line</span>
00481                         <span class="keywordflow">break</span>;
00482                 }
00483                 uint32 nCurrentPos = nCurrentCacheLineIndex * vhdABTTree::nCacheLineNodes + listElement.begin()-&gt;id; 
00484 
00485                 <span class="keywordflow">if</span> ((_pNode[nCurrentPos].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[BITLEAF] &amp; MASK_ISLEAF) == MASK_ISLEAF)
00486                 {
00487                         <span class="comment">//this is a leaf,</span>
00488                         <span class="comment">//skip it (ony if local root is leaf, could be done once only)</span>
00489                         listElement.pop_front();
00490                         <span class="keywordflow">continue</span>;
00491                 }
00492                 
00493                 <a class="code" href="classvhd_axis_aligned_box.html">vhdAxisAlignedBox</a> boxLeft,boxRight;
00494                 _computeChildBox(listElement.begin()-&gt;bbox,boxLeft,boxRight, nCurrentPos);
00495                 
00496                 
00497                 <span class="comment">//check if left  need to be split</span>
00498                 <span class="keywordflow">if</span> (_needToSplit(boxLeft,nCurrentPos,<span class="keyword">true</span>))
00499                 {
00500                         _makeChildren(listElement,boxLeft,nCurrentPos,nCurrentCacheLineIndex * vhdABTTree::nCacheLineNodes + listElement.begin()-&gt;id*2 + 1, listElement.begin()-&gt;id*2 + 1,<span class="keyword">true</span>);        
00501                 }
00502                 <span class="keywordflow">else</span>
00503                 {
00504                         _makeLeaf(nCurrentCacheLineIndex * vhdABTTree::nCacheLineNodes + listElement.begin()-&gt;id,nCurrentCacheLineIndex * vhdABTTree::nCacheLineNodes + listElement.begin()-&gt;id*2 + 1,<span class="keyword">true</span>);
00505                 }
00506                 <span class="comment">//right</span>
00507                 <span class="keywordflow">if</span> (_needToSplit(boxRight,nCurrentPos,<span class="keyword">false</span>))
00508                 {
00509                         _makeChildren(listElement,boxRight,nCurrentPos,nCurrentCacheLineIndex * vhdABTTree::nCacheLineNodes + listElement.begin()-&gt;id*2 + 2,listElement.begin()-&gt;id*2 + 2,<span class="keyword">false</span>);       
00510                 }
00511                 <span class="keywordflow">else</span>
00512                 {
00513                         _makeLeaf(nCurrentCacheLineIndex * vhdABTTree::nCacheLineNodes + listElement.begin()-&gt;id,nCurrentCacheLineIndex * vhdABTTree::nCacheLineNodes + listElement.begin()-&gt;id*2 + 2,<span class="keyword">false</span>);
00514                 }
00515                 listElement.pop_front();        
00516         }
00517 
00518         <span class="keywordflow">if</span> (listElement.size()&gt;0)
00519 
00520         {
00521                 <span class="comment">//at this stage, we need to handle the final line of this sub-tree</span>
00522                 <span class="keywordtype">bool</span> bFirst(<span class="keyword">true</span>);
00523                 uint32 i;
00524                 ListElement::iterator it(listElement.begin());
00525                 <span class="keywordflow">for</span> ( i = nSubTreeId ; i &lt; vhdABTTree::nCacheLineNodes-1; ++i)
00526                 {
00527                         <span class="keywordflow">if</span> ( it-&gt;id != i)
00528                         {
00529                                 <span class="comment">//this potential node is not existing, so skipt it</span>
00530                                 <span class="keywordflow">continue</span>;
00531                         }
00532                         uint32 nCurrentPos = nCurrentCacheLineIndex * vhdABTTree::nCacheLineNodes + it-&gt;id; 
00533                         <span class="keywordflow">if</span> ( (_pNode[nCurrentPos].<a class="code" href="unionvhd_a_b_t_tree_node.html#o1">node</a>.<a class="code" href="classvhd_a_b_t_tree_node_data.html#o0">data</a>[BITLEAF] &amp; MASK_ISLEAF) == MASK_ISLEAF)
00534                         {
00535                                 <span class="comment">//this is a leaf, so we don't care      </span>
00536                                 ++it;
00537                                 <span class="keywordflow">continue</span>;
00538                         }
00539                         _nFirstFreeCacheLineIndex+=2; <span class="comment">//for left and right</span>
00540 <span class="preprocessor">                        #ifdef TREE_DEBUG</span>
00541 <span class="preprocessor"></span>                        std::cout &lt;&lt; <span class="stringliteral">"_nFirstFreeCacheLineIndex internal "</span>  &lt;&lt; _nFirstFreeCacheLineIndex &lt;&lt; std::endl;
00542 <span class="preprocessor">                        #endif</span>
00543 <span class="preprocessor"></span>                        <span class="keywordflow">if</span> (bFirst)
00544                         {
00545                                 <span class="comment">//setup the next children into the line</span>
00546                                 bFirst = <span class="keyword">false</span>;
00547                                 _pNode[(nCurrentCacheLineIndex+1) * vhdABTTree::nCacheLineNodes -1 ].<a class="code" href="unionvhd_a_b_t_tree_node.html#o0">leaf</a>.<a class="code" href="classvhd_a_b_t_tree_leaf_data.html#o0">index</a> = _nFirstFreeCacheLineIndex-1; <span class="comment">//point to the left</span>
00548                         }
00549                         <span class="comment">//set this node as a non-leaf for continuity, use during traversal</span>
00550                         uint32 mask = 0x1 &lt;&lt; (i-nSubTreeId);
00551                         _pNode[(nCurrentCacheLineIndex+1) * vhdABTTree::nCacheLineNodes -1 ].<a class="code" href="unionvhd_a_b_t_tree_node.html#o0">leaf</a>.<a class="code" href="classvhd_a_b_t_tree_leaf_data.html#o1">callback</a> = _pNode[(nCurrentCacheLineIndex+1) * vhdABTTree::nCacheLineNodes -1 ].<a class="code" href="unionvhd_a_b_t_tree_node.html#o0">leaf</a>.<a class="code" href="classvhd_a_b_t_tree_leaf_data.html#o1">callback</a> | mask;
00552                         
00553                         ++it;
00554                 }
00555 
00556                 uint32 nChildIndex=_pNode[(nCurrentCacheLineIndex+1) * vhdABTTree::nCacheLineNodes -1 ].<a class="code" href="unionvhd_a_b_t_tree_node.html#o0">leaf</a>.<a class="code" href="classvhd_a_b_t_tree_leaf_data.html#o0">index</a>;
00557                 <span class="keywordflow">for</span> ( it = listElement.begin(); it != listElement.end(); ++it)
00558                 {
00559                         <span class="comment">//recursive call</span>
00560                         <a class="code" href="classvhd_axis_aligned_box.html">vhdAxisAlignedBox</a> boxLeft,boxRight;
00561                         _computeChildBox(listElement.begin()-&gt;bbox,boxLeft,boxRight, nCurrentCacheLineIndex * vhdABTTree::nCacheLineNodes + listElement.begin()-&gt;id);
00562                         <span class="comment">//left</span>
00563                         <span class="comment">//first el is not a leaf</span>
00564                         _pNode[nChildIndex*vhdABTTree::nCacheLineNodes].node.data[BITLEAF] = MASK_NULL;
00565                         <span class="comment">//we need to provide the next right and left here, so lets do it!</span>
00566                         <a class="code" href="classvhd_axis_aligned_box.html">vhdAxisAlignedBox</a> boxLeftL,boxRightL;
00567                         
00568                         vhdSceneConverterABTTree::getSingleton().<a class="code" href="classvhd_scene_converter_a_b_t_tree.html#a2">getChildren</a>(vhdSceneConverterABTTree::getSingleton().mapNodeChild[nCurrentCacheLineIndex * vhdABTTree::nCacheLineNodes + it-&gt;id].pLeft ,nChildIndex*vhdABTTree::nCacheLineNodes, boxLeftL, boxRightL);
00569                         _makeNodeDataFlags(nChildIndex*vhdABTTree::nCacheLineNodes,it-&gt;bbox,boxLeftL, boxRightL);
00570                         subTreeBuild(nChildIndex++,boxLeft);
00571                         
00572                         vhdSceneConverterABTTree::getSingleton().<a class="code" href="classvhd_scene_converter_a_b_t_tree.html#a2">getChildren</a>(vhdSceneConverterABTTree::getSingleton().mapNodeChild[nCurrentCacheLineIndex * vhdABTTree::nCacheLineNodes + it-&gt;id].pRight ,nChildIndex*vhdABTTree::nCacheLineNodes, boxLeftL, boxRightL);
00573                         _makeNodeDataFlags(nChildIndex*vhdABTTree::nCacheLineNodes,it-&gt;bbox,boxLeftL, boxRightL);
00574                         subTreeBuild(nChildIndex++,boxRight);
00575                         
00576                 }
00577         }
00578 }
00579 
00580 
00581 
00582 
00583 <span class="keywordtype">bool</span> 
00584 vhdABTTree::_isVisible(<span class="keyword">const</span> <a class="code" href="classvhd_axis_aligned_box.html">vhdAxisAlignedBox</a> &amp; box)
00585 {
00586         <span class="comment">//default callback -&gt; all node are visile</span>
00587         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00588 }
00589 
00590 
00591 <span class="keywordtype">void</span>
<a name="l00592"></a><a class="code" href="classvhd_a_b_t_tree.html#a1">00592</a> <a class="code" href="classvhd_a_b_t_tree.html#a1">vhdABTTree::traversal</a>()
00593 {
00594         <span class="comment">//we start from the root -&gt; so _box</span>
00595         _traversal(0,_bbox);
00596 }
00597 
00598 <span class="keywordtype">void</span>
00599 vhdABTTree::_traversal(uint32 nCurrentCacheLineIndex,<span class="keyword">const</span> <a class="code" href="classvhd_axis_aligned_box.html">vhdAxisAlignedBox</a> &amp; box)
00600 {
00601         
00602 <span class="preprocessor">        #ifdef TREE_DEBUG</span>
00603 <span class="preprocessor"></span>                std::cout &lt;&lt; <span class="stringliteral">"_traversal "</span> &lt;&lt; nCurrentCacheLineIndex &lt;&lt; std::endl;
00604 <span class="preprocessor">        #endif</span>
00605 <span class="preprocessor"></span>        <span class="comment">//1) we need to try to traverse a complete sub-tree</span>
00606         ListElement listElement;
00607         listElement.push_back(Element(0,box));
00608 
00609         <span class="keywordflow">while</span> (listElement.size()&gt;0)
00610         {
00611                 <span class="comment">//check if we are not at the last line of the sub-tree</span>
00612                 <span class="keywordflow">if</span> ( listElement.begin()-&gt;id &gt;= nSubTreeId)
00613                 {
00614                         <span class="comment">//we reach the end line</span>
00615                         <span class="keywordflow">break</span>;
00616                 }
00617 
00618                 uint32 nCurrentPos = nCurrentCacheLineIndex * vhdABTTree::nCacheLineNodes + listElement.begin()-&gt;id; 
00619 
00620                 <span class="keywordflow">if</span> ( (_pNode[nCurrentPos].node.data[BITLEAF] &amp; MASK_ISLEAF)  == MASK_ISLEAF)
00621                 {
00622                         <span class="comment">//this is a leaf,</span>
00623                         <span class="comment">//TO DO NOTIFY THAT WE NEED TO RENDER THIS LEAF</span>
00624                         uint32 index = _pNode[nCurrentPos].leaf.index &gt;&gt; MASK_ISLEAF;
00625                         <span class="comment">//we notify that this leaf is visible.</span>
00626 <span class="preprocessor">                        #ifdef TREE_DEBUG</span>
00627 <span class="preprocessor"></span>                                std::cout &lt;&lt; <span class="stringliteral">"_pNode[nCurrentPos] need to be render "</span> &lt;&lt; nCurrentPos  &lt;&lt; <span class="stringliteral">" and leaf is "</span> &lt;&lt; index &lt;&lt; std::endl;
00628 <span class="preprocessor">                        #endif</span>
00629 <span class="preprocessor"></span>                        <a class="code" href="classvhd_a_b_t_tree.html#o1">funcVisit</a>(nCurrentPos, index,listElement.begin()-&gt;bbox);
00630                         listElement.pop_front();
00631                         <span class="keywordflow">continue</span>;
00632                 }
00633                 
00634                 <a class="code" href="classvhd_axis_aligned_box.html">vhdAxisAlignedBox</a> boxLeft,boxRight;
00635                 _computeChildBox(listElement.begin()-&gt;bbox,boxLeft,boxRight, nCurrentPos);
00636                 
00637                 
00638                 <span class="comment">//check if left  need to be split</span>
00639                 <span class="keywordflow">if</span> (<a class="code" href="classvhd_a_b_t_tree.html#o0">funcIsVisible</a>(boxLeft))
00640                 {
00641                         <span class="comment">//add the new leaf  with the number </span>
00642                         listElement.push_back(Element(listElement.begin()-&gt;id*2 + 1,boxLeft));
00643                 }
00644                 <span class="comment">//right</span>
00645                 <span class="keywordflow">if</span> (<a class="code" href="classvhd_a_b_t_tree.html#o0">funcIsVisible</a>(boxRight))
00646                 {
00647                         <span class="comment">//add the new leaf  with the number </span>
00648                         listElement.push_back(Element(listElement.begin()-&gt;id*2 + 2,boxRight));
00649                 }
00650                 listElement.pop_front();        
00651         }
00652         
00653         <span class="comment">//now we reach the end line of this sub-tree</span>
00654         
00655         <span class="comment">//take the index to the first children</span>
00656         uint32 nNextChildren = _pNode[(nCurrentCacheLineIndex+1) * vhdABTTree::nCacheLineNodes - 1].leaf.index;
00657 
00658         uint32 i;
00659         ListElement::iterator it(listElement.begin());
00660         <span class="keywordflow">for</span> ( i = nSubTreeId ; i &lt; vhdABTTree::nCacheLineNodes; ++i)
00661         {
00662                 <span class="keywordflow">if</span> (it == listElement.end())
00663                 {
00664                         <span class="keywordflow">break</span>;
00665                 }
00666                 uint32 nCurrentPos = nCurrentCacheLineIndex * vhdABTTree::nCacheLineNodes + it-&gt;id; <span class="comment">//nNextChildren * vhdABTTree::nCacheLineNodes + it-&gt;id; </span>
00667                 <span class="keywordflow">if</span> (nNextChildren==0)
00668                 {
00669                         <span class="comment">//mean a leaf here</span>
00670                         <span class="comment">//this is a leaf, so we render it</span>
00671                         <span class="comment">//TO DO NOTIFY THAT WE NEED TO RENDER THIS LEAF</span>
00672                         uint32 index = _pNode[nCurrentPos].leaf.index &gt;&gt; MASK_ISLEAF;
00673 <span class="preprocessor">                        #ifdef TREE_DEBUG</span>
00674 <span class="preprocessor"></span>                        std::cout &lt;&lt; <span class="stringliteral">"_pNode[nCurrentPos] need to be render "</span> &lt;&lt; nCurrentPos &lt;&lt;  <span class="stringliteral">" and leaf is "</span> &lt;&lt; index &lt;&lt; std::endl;
00675 <span class="preprocessor">                        #endif</span>
00676 <span class="preprocessor"></span>                        <a class="code" href="classvhd_a_b_t_tree.html#o1">funcVisit</a>(nCurrentPos, index,it-&gt;bbox);
00677                         <span class="comment">//listElement.pop_front();</span>
00678                         ++it;
00679                         <span class="keywordflow">continue</span>;
00680                 }
00681                 
00682                 
00683         
00684 
00685                 <span class="keywordflow">if</span> ( it-&gt;id != i)
00686                 {
00687                         <span class="comment">//this potential node is not existing, so skipt it</span>
00688                         <span class="keywordflow">continue</span>;
00689                 }
00690                 <span class="keywordflow">if</span> ( (_pNode[nCurrentPos].node.data[BITLEAF] &amp; MASK_ISLEAF) == MASK_ISLEAF)
00691                 {
00692                         <span class="comment">//this is a leaf, so we render it</span>
00693                         uint32 index = _pNode[nCurrentPos].leaf.index &gt;&gt; MASK_ISLEAF;
00694 <span class="preprocessor">                        #ifdef TREE_DEBUG</span>
00695 <span class="preprocessor"></span>                        std::cout &lt;&lt; <span class="stringliteral">"_pNode[nCurrentPos] need to be render "</span> &lt;&lt; nCurrentPos  &lt;&lt; <span class="stringliteral">" and leaf is "</span> &lt;&lt; index &lt;&lt; std::endl;
00696 <span class="preprocessor">                        #endif</span>
00697 <span class="preprocessor"></span>                        <a class="code" href="classvhd_a_b_t_tree.html#o1">funcVisit</a>(nCurrentPos, index,it-&gt;bbox);
00698                         <span class="comment">//listElement.pop_front();</span>
00699                         ++it;
00700                         <span class="keywordflow">continue</span>;
00701                 }
00702                 <span class="comment">//check the flags </span>
00703                 uint32 mask = 0x1 &lt;&lt; (i-nSubTreeId);
00704                 <span class="keywordflow">if</span> ((_pNode[(nCurrentCacheLineIndex+1) * vhdABTTree::nCacheLineNodes -1 ].leaf.callback  &amp; mask) == mask)
00705                 {
00706                         <span class="comment">//this node would have a two child</span>
00707                         nNextChildren+=2; <span class="comment">//for left and right</span>
00708                 }
00709                 
00710                 <span class="comment">//we need to check for the children from here,so as we have already increment the index</span>
00711                 <span class="comment">//recursive call.</span>
00712                 <a class="code" href="classvhd_axis_aligned_box.html">vhdAxisAlignedBox</a> boxLeft,boxRight;
00713                 _computeChildBox(it-&gt;bbox,boxLeft,boxRight, nCurrentPos);
00714                 <span class="comment">//left</span>
00715                 <span class="comment">//check if left  need to be split</span>
00716                 <span class="keywordflow">if</span> (<a class="code" href="classvhd_a_b_t_tree.html#o0">funcIsVisible</a>(boxLeft))
00717                 {
00718                         _traversal(nNextChildren-2, boxLeft); 
00719                 }
00720                 <span class="comment">//right</span>
00721                 <span class="keywordflow">if</span> (<a class="code" href="classvhd_a_b_t_tree.html#o0">funcIsVisible</a>(boxRight))
00722                 {
00723                         _traversal(nNextChildren-1,boxRight);
00724                 }
00725 
00726 
00727                 ++it;
00728         }
00729 
00730 }
00731 
00732 
00733 
00734 
00735 
00736 
00737 
00738 
00739 
00740 
00741 
00742 
00743 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sun Oct 3 16:32:22 2004 for vhdABTTree by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.8 </small></address>
</body>
</html>
